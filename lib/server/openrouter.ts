import { createClient } from "@supabase/supabase-js";
import type { PlanType } from "@/types";

type PlanKey = "standard" | "premium";
type ChatMessage = { role: "system" | "user" | "assistant"; content: string };

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const openRouterKey = process.env.OPENROUTER_API_KEY;
const openRouterBaseUrl = process.env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";
const openRouterReferer = process.env.OPENROUTER_REFERER || process.env.NEXT_PUBLIC_SITE_URL;
const openRouterTitle = process.env.OPENROUTER_TITLE || "conflictresolution-nextjs";

const supabaseAdmin =
  supabaseUrl && serviceRoleKey
    ? createClient(supabaseUrl, serviceRoleKey, {
        auth: { persistSession: false, autoRefreshToken: false },
      })
    : null;

const normalizePlan = (planType?: PlanType | string): PlanKey =>
  planType === "premium" ? "premium" : "standard";

const getUserIdFromToken = async (authToken?: string | null): Promise<string | null> => {
  if (!authToken || !supabaseAdmin) return null;
  const { data, error } = await supabaseAdmin.auth.getUser(authToken);
  if (error) return null;
  return data?.user?.id ?? null;
};

export const resolveModelSlug = async (
  planType?: PlanType | string,
  authToken?: string | null
): Promise<string> => {
  if (!supabaseAdmin) {
    throw new Error("Server configuration error");
  }

  const planKey = normalizePlan(planType);
  const profileColumn = planKey === "premium" ? "premium_model_id" : "standard_model_id";

  const userId = await getUserIdFromToken(authToken);
  let profileModelId: number | null = null;

  if (userId) {
    const { data, error } = await supabaseAdmin
      .from("profiles")
      .select(profileColumn)
      .eq("id", userId)
      .single();
    if (!error) {
      profileModelId = (data as Record<string, number | null>)?.[profileColumn] ?? null;
    }
  }

  let modelId = profileModelId;
  let modelSlug: string | null = null;

  if (!modelId) {
    const { data, error } = await supabaseAdmin
      .from("ai_models")
      .select("id, model_slug")
      .eq("plan_type", planKey)
      .single();

    if (error || !data?.id || !data?.model_slug) {
      throw new Error("Model configuration error");
    }

    modelId = data.id;
    modelSlug = data.model_slug;

    if (userId && profileModelId === null) {
      await supabaseAdmin.from("profiles").update({ [profileColumn]: modelId }).eq("id", userId);
    }
  }

  if (!modelSlug) {
    const { data, error } = await supabaseAdmin
      .from("ai_models")
      .select("model_slug")
      .eq("id", modelId)
      .single();
    if (error || !data?.model_slug) {
      throw new Error("Model configuration error");
    }
    modelSlug = data.model_slug;
  }

  return modelSlug;
};

export const callOpenRouterChat = async (params: {
  model: string;
  messages: ChatMessage[];
  temperature?: number;
  max_tokens?: number;
}): Promise<string> => {
  if (!openRouterKey) {
    throw new Error("Server configuration error");
  }

  const headers: Record<string, string> = {
    Authorization: `Bearer ${openRouterKey}`,
    "Content-Type": "application/json",
  };
  if (openRouterReferer) {
    headers["HTTP-Referer"] = openRouterReferer;
  }
  if (openRouterTitle) {
    headers["X-Title"] = openRouterTitle;
  }

  const response = await fetch(`${openRouterBaseUrl}/chat/completions`, {
    method: "POST",
    headers,
    body: JSON.stringify({
      model: params.model,
      messages: params.messages,
      temperature: params.temperature,
      max_tokens: params.max_tokens,
    }),
  });

  const responseText = await response.text();
  let payload: any = null;
  if (responseText) {
    try {
      payload = JSON.parse(responseText);
    } catch {
      payload = null;
    }
  }

  if (!response.ok) {
    const detail = payload?.error?.message || responseText;
    const suffix = detail ? `: ${detail}` : "";
    throw new Error(`OpenRouter error ${response.status}${suffix}`);
  }

  if (!payload) {
    throw new Error("Invalid JSON from AI provider");
  }

  const content = payload?.choices?.[0]?.message?.content;
  if (!content) {
    throw new Error("No text generated by AI.");
  }

  return content;
};
